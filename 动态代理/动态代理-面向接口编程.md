

## 代理模式
  >将一个对象的直接访问,变为访问这个对象的代理对象,通过代理对象间接的访问原本的对象

  **为什么需要代理呢?**
  因为一个良好的设计不应该被轻易地修改,这正是开闭原则的体现: 一个良好的设计应该对修改关闭, 对扩展开放。
而代理正是为了扩展类的而存在的, 其可以控制对现有类服务的访问。

## 类的加载
  
  

## 远程调用的魔法
在项目中，当我们要使用 RPC 的时候，我们一般的做法是先找服务提供方要接口，通过Maven 或者其他的工具把接口
依赖到我们项目中。我们在编写业务逻辑的时候，如果要调用提供方的接口，我们就只需要通过依赖注入的方式把接口
注入到项目中就行了，然后在代码里面直接调用接口的方法 。

我们都知道，接口里并不会包含真实的业务逻辑，业务逻辑都在服务提供方应用里，但我们
通过调用接口方法，确实拿到了想要的结果，是不是感觉有点神奇呢？想一下，在 RPC 里
面，我们是怎么完成这个魔术的。

**核心技术就是动态代理**, RPC 会自动给接口生成一个代理类，当我
们在项目中注入接口的时候，运行过程中实际绑定的是这个接口生成的代理类。这样在接口
方法被调用的时候，它实际上是被生成代理类拦截到了，这样我们就可以在生成的代理类里
面，加入远程调用逻辑。
通过这种“偷梁换柱”的手法，就可以帮用户屏蔽远程调用的细节，实现像调用本地一样地
调用远程的体验，整体流程如下图所示：
![1586417919867](./img/rpc_dtdl.png)

