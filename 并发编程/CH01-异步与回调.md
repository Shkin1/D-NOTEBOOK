
 异步使用子线程实现, 回调就是调用另一类去调用自己(通过回调接口, 自己得实现这个接口)

 异步回调, 就是使用子线程去调用另一个类去调用自己的回调方法

> 哪边想要回调,哪边就实现回调接口, 回调其实就是方法里传接口==>接口编程而已 




## 1. 异步化
 一般我们用多线程优化性能,其实不过就是将串行操作变成并行操作。
 如果仔细观察, 你还会发现在串行转换成并行的过程中, 一定会涉及到异步化。


 > 例: 为提升性能将以下串行任务变为并行任务
 ```java
 // 串行
JobA();
JobB();

/** 使用两个子线程去执行,实现并行。
* 主线程无需等待JobA或者JobB的执行结果 = JobA与JobB两个操作已经被异步化
*/
new Thread(()->JobA()).start();
new Thread(()->JobB()).start();
 ```

**异步化**,是并行方案得以实施的基础,更深入地讲其实就是: **利用多线程优化性能这个核心方案得以实施的基础**

目前JDK1.8提供了CompletableFuture 来支持异步编程(JDK1.8之前的Future没有实现真正的异步回调,
get()获取结果,该方法会阻塞当前线程,非阻塞的方式isDone(),需要主线程循环询问子线程是否完成) 

 ## 2. 回调
 >核心:接口作为方法参数，其实际传入引用指向的是实现类


 ### 2.1 什么是回调
 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调用、回调和异步调用。

 >在计算机程序设计中，回调函数，或简称回调，是指通过函数参数传递到其它代码的某一块可执行代码的引用。
 >这一设计允许了底层代码调用在高层定义的子程序

 具体说来：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，

 ### 2.2 三种方式的回调
 回调是一种特殊的调用, 有3种方式的回调:

 - 同步回调，即阻塞，单向。
 - 回调，即双向（类似自行车的两个齿轮）。
 - 异步调用，即通过异步消息进行通知。

 #### 2.2.1 同步调用
 一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用
 ```python
 a() {
    print "a";
 }
 b() {
    a();
    print "b";
  }
 ```

 #### 2.2.2 回调
 一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；

 代码模拟经典场景:  客户端向服务端发送请求, 服务端处理完请求然后进行响应

 [见代码](./src/main/java/CH01/回调/SYNC_CS/CallBack.java)

*结果测试方法:*

```java
        // one-by-one式请求, 服务器方同步式处理响应
        client.request("仿真运行请求1");
        System.out.println("--------------over-----------------");
        client.request("仿真运行请求2");
        System.out.println("--------------over-----------------");
        client.request("仿真运行请求3");
        System.out.println("--------------over-----------------");
```

*运行情况:*

```java
1. 客户端发起请求: 仿真运行请求1
2. 服务端: 服务端接收到客户端请求消息:仿真运行请求1
3. 服务端处理逻辑ing....
4. 服务端: 数据处理成功, 状态码 200, 返回结果
5. 客户端: 接受到服务端响应的消息状态码 200, 响应结果内容*****
--------------over-----------------
1. 客户端发起请求: 仿真运行请求2
2. 服务端: 服务端接收到客户端请求消息:仿真运行请求2
3. 服务端处理逻辑ing....
4. 服务端: 数据处理成功, 状态码 200, 返回结果
5. 客户端: 接受到服务端响应的消息状态码 200, 响应结果内容*****
--------------over-----------------
1. 客户端发起请求: 仿真运行请求3
2. 服务端: 服务端接收到客户端请求消息:仿真运行请求3
3. 服务端处理逻辑ing....
4. 服务端: 数据处理成功, 状态码 200, 返回结果
5. 客户端: 接受到服务端响应的消息状态码 200, 响应结果内容*****
--------------over-----------------
```





 #### 2.2.3 异步回调
 一种类似消息或事件的机制，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口)

 >异步回调核心还是的配合多线程+回调实现

 2.2.2 是同步的One-By-One, 客户端向服务器发起请求，服务器给出响应，客户端得到响应之后继续下一个请求

但实际在使用这种CS场景中,更多的是异步的场景,即客户端更多是的并发的发起不同的请求, 而服务端并不是同步的处理请求,而是多个线程去处理以提高响应效率

为实现这种场景, 代码如下:  [见异步回调实现代码](./src/main/java/CH01/回调/ASYNC_CS/CallBack.java)

*测试方法:*

```java
        // 主线程异步发送3个请求
        client.request("仿真运行请求1");
        client.request("仿真运行请求2");
        client.request("仿真运行请求3");
```

*运行情况:*

```
1. 客户端发起请求(异步方式): 仿真运行请求1

1. 客户端发起请求(异步方式): 仿真运行请求2

1. 客户端发起请求(异步方式): 仿真运行请求3

2. 服务端: 服务端接收到客户端请求消息:仿真运行请求1 当前线程: Thread-0
2. 服务端: 服务端接收到客户端请求消息:仿真运行请求2 当前线程: Thread-1

3. 服务端处理逻辑ing.... 当前线程:Thread-1

2. 服务端: 服务端接收到客户端请求消息:仿真运行请求3 当前线程: Thread-2


3. 服务端处理逻辑ing.... 当前线程:Thread-0

3. 服务端处理逻辑ing.... 当前线程:Thread-2

4. 服务端: 数据处理成功, 状态码 200, 返回结果

4. 服务端: 数据处理成功, 状态码 200, 返回结果

5. 客户端: 接受到服务端响应的消息状态码 200, 响应结果内容***** 当前线程: Thread-2
4. 服务端: 数据处理成功, 状态码 200, 返回结果

5. 客户端: 接受到服务端响应的消息状态码 200, 响应结果内容***** 当前线程: Thread-1
5. 客户端: 接受到服务端响应的消息状态码 200, 响应结果内容***** 当前线程: Thread-0
```

 

 
