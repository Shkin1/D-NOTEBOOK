







## 1. 异步化
 一般我们用多线程优化性能,其实不过就是将串行操作变成并行操作。
 如果仔细观察, 你还会发现在串行转换成并行的过程中, 一定会涉及到异步化。
 
 
 > 例: 为提升性能将以下串行任务变为并行任务
 ```java
 // 串行
JobA();
JobB();

/** 使用两个子线程去执行,实现并行。
* 主线程无需等待JobA或者JobB的执行结果 = JobA与JobB两个操作已经被异步化
*/
new Thread(()->JobA()).start();
new Thread(()->JobB()).start();
```

**异步化**,是并行方案得以实施的基础,更深入地讲其实就是: **利用多线程优化性能这个核心方案得以实施的基础**

目前JDK1.8提供了CompletableFuture 来支持异步编程(JDK1.8之前的Future没有实现真正的异步回调,
get()获取结果,该方法会阻塞当前线程,非阻塞的方式isDone(),需要主线程循环询问子线程是否完成) 
 
 ## 2. 回调
 >核心:接口作为方法参数，其实际传入引用指向的是实现类
 
 
 ### 2.1 什么是回调
 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调用、回调和异步调用。

 >在计算机程序设计中，回调函数，或简称回调，是指通过函数参数传递到其它代码的某一块可执行代码的引用。
 >这一设计允许了底层代码调用在高层定义的子程序
 
 具体说来：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，
 
 ### 2.2 三种方式的回调
 回调是一种特殊的调用, 有3种方式的回调:
 
 - 同步回调，即阻塞，单向。
 - 回调，即双向（类似自行车的两个齿轮）。
 - 异步调用，即通过异步消息进行通知。
 
 #### 2.2.1 同步调用
 一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用
 ```python
 a() {
    print "a";
 }
 b() {
    a();
    print "b";
  }
```

 #### 2.2.2 回调
 一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；
 
 代码模拟经典场景: 老师问学生问题, 学生思考完毕回答老师
 
 [见代码]()
 
 #### 2.2.3 异步回调
 一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口)
 
 2.2.2的提问是同步的One-By-One,老师向Ricky问问题，Ricky给出答案，老师问下一个同学，得到答案之后继续问下一个同学，这是一种正常的场景
 但把场景改成如下场景:
 
 *老师并不想One-By-One这样提问，而是同时向Ricky、Mike、Lucy、Bruce、Kate五位同学提问，让同学们自己思考，哪位同学思考好了就直接告诉老师答案即可。*
 
这种场景相当于是说，同学思考完毕完毕问题要有一个办法告诉老师，有两个解决方案：

- 1.使用Future+Callable的方式，等待异步线程执行结果，这相当于就是同步调用的一种变种，因为其本质还是方法返回一个结果，即学生的回答
- 2.使用异步回调，同学回答完毕问题，调用回调接口方法告诉老师答案即可。由于老师对象被抽象成了Callback接口，因此这种做法的扩展性非常好，
就像之前说的，即使老师换了换了一茬又一茬，对于同学来说，只关心的是调用Callback接口回传必要的信息即可
 
 
 
 
 